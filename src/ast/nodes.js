/**
 * Weilang AST (Abstract Syntax Tree) Node Definitions
 *
 * This module defines the structure of the AST nodes used to represent
 * Weilang programs. The AST is a simplified, interpreter-friendly
 * representation of the parse tree generated by ANTLR.
 *
 * Design Philosophy:
 * - Each node type represents a semantic concept in Weilang
 * - Nodes are plain JavaScript objects (can be easily serialized)
 * - Temporal markers, intentionality modifiers, and punctuation are
 *   preserved as metadata affecting execution semantics
 * - Material qualities are stored with variables
 * - Non-determinism is represented explicitly in PossibilityNode
 */

// ============================================================================
// BASE NODE
// ============================================================================

/**
 * Base class for all AST nodes
 * All nodes have a type field for pattern matching during interpretation
 */
export class ASTNode {
  constructor(type) {
    this.type = type;
  }
}

// ============================================================================
// PROGRAM & STRUCTURE
// ============================================================================

/**
 * Root node of the AST
 * Represents the entire Weilang program
 */
export class ProgramNode extends ASTNode {
  /**
   * @param {Array<PossibilityNode>} possibilities - Top-level possibilities
   */
  constructor(possibilities) {
    super('Program');
    this.possibilities = possibilities;
  }
}

/**
 * Possibility space - fundamental unit of non-determinism
 * Represents one or more possible execution paths
 */
export class PossibilityNode extends ASTNode {
  /**
   * @param {Array<StatementNode>} statements - Statements in this possibility
   * @param {Array<StatementNode>|null} alternatives - Alternative execution paths
   * @param {string|null} combinator - How alternatives are combined: 'OR NOT', 'RATHER THAN', 'EITHER'
   */
  constructor(statements, alternatives = null, combinator = null) {
    super('Possibility');
    this.statements = statements;
    this.alternatives = alternatives;
    this.combinator = combinator; // null, 'OR NOT', 'RATHER THAN', 'EITHER'
  }
}

/**
 * Statement - wraps core statements with execution modifiers
 */
export class StatementNode extends ASTNode {
  /**
   * @param {ASTNode} coreStatement - The actual statement (assignment, conditional, etc.)
   * @param {string|null} temporalMarker - When the statement exists in time
   * @param {string|null} intentionalityModifier - Execution modality
   * @param {string|null} punctuation - Execution certainty: '.', '!', '?'
   */
  constructor(coreStatement, temporalMarker = null, intentionalityModifier = null, punctuation = null) {
    super('Statement');
    this.coreStatement = coreStatement;
    this.temporalMarker = temporalMarker;
    this.intentionalityModifier = intentionalityModifier;
    this.punctuation = punctuation;
  }
}

// ============================================================================
// CORE STATEMENTS
// ============================================================================

/**
 * Assignment - creating or updating a variable
 */
export class AssignmentNode extends ASTNode {
  /**
   * @param {string} identifier - Variable name (without framing pipes)
   * @param {ExpressionNode} value - Value to assign
   * @param {Array<string>} materialQualities - Physical properties: ['OF STONE', 'POLISHED', ...]
   */
  constructor(identifier, value, materialQualities = []) {
    super('Assignment');
    this.identifier = identifier;
    this.value = value;
    this.materialQualities = materialQualities;
  }
}

/**
 * Removal - deleting a variable (Weiner's concept of absence)
 */
export class RemovalNode extends ASTNode {
  /**
   * @param {string} identifier - Variable to remove
   * @param {string} removalType - Type of removal: 'REMOVE', 'UN-PLACED', 'ABSENCE OF', 'THE REMOVAL TO THE LATHING OF'
   */
  constructor(identifier, removalType) {
    super('Removal');
    this.identifier = identifier;
    this.removalType = removalType;
  }
}

/**
 * Conditional - if/then/else control flow
 */
export class ConditionalNode extends ASTNode {
  /**
   * @param {ExpressionNode} condition - Condition to evaluate
   * @param {Array<StatementNode>} thenStatements - Statements if condition is true
   * @param {Array<StatementNode>} elseStatements - Statements if condition is false
   * @param {string} conditionType - Type of condition: 'IF AS IF', 'IF PRESENT', 'IF ABSENT', etc.
   */
  constructor(condition, thenStatements, elseStatements = [], conditionType = 'IF AS IF') {
    super('Conditional');
    this.condition = condition;
    this.thenStatements = thenStatements;
    this.elseStatements = elseStatements;
    this.conditionType = conditionType;
  }
}

/**
 * Loop - repetition constructs
 */
export class LoopNode extends ASTNode {
  /**
   * @param {Array<StatementNode>} body - Statements to repeat
   * @param {string} loopType - Type: 'OVER AND OVER', 'UNTIL OTHERWISE', 'PERPETUALLY', 'REPEATED TIMES'
   * @param {ExpressionNode|null} condition - Loop condition (for UNTIL OTHERWISE)
   * @param {ExpressionNode|null} count - Number of iterations (for REPEATED TIMES)
   * @param {string|null} iteratorVar - Iterator variable name (for EACH IN)
   * @param {ExpressionNode|null} iterableExpr - Expression to iterate over (for EACH IN)
   */
  constructor(body, loopType, condition = null, count = null, iteratorVar = null, iterableExpr = null) {
    super('Loop');
    this.body = body;
    this.loopType = loopType;
    this.condition = condition;
    this.count = count;
    this.iteratorVar = iteratorVar;
    this.iterableExpr = iterableExpr;
  }
}

/**
 * Function Declaration
 */
export class FunctionDeclarationNode extends ASTNode {
  /**
   * @param {string} name - Function name
   * @param {Array<string>} parameters - Parameter names
   * @param {Array<StatementNode>} body - Function body
   */
  constructor(name, parameters, body) {
    super('FunctionDeclaration');
    this.name = name;
    this.parameters = parameters;
    this.body = body;
  }
}

/**
 * Function Call
 */
export class FunctionCallNode extends ASTNode {
  /**
   * @param {string} name - Function name to call
   * @param {Array<ExpressionNode>} arguments - Arguments to pass
   */
  constructor(name, args) {
    super('FunctionCall');
    this.name = name;
    this.arguments = args;
  }
}

/**
 * Return Statement
 */
export class ReturnNode extends ASTNode {
  /**
   * @param {ExpressionNode} value - Value to return
   */
  constructor(value) {
    super('Return');
    this.value = value;
  }
}

/**
 * Observer Action - output and observation
 */
export class ObserverActionNode extends ASTNode {
  /**
   * @param {string} actionType - Type of observation:
   *   'PLACED UPON A WALL', 'SPOKEN ALOUD', 'WHISPERED', 'INSCRIBED',
   *   'PRESENTED AS', 'HOLD IN MIND', 'NOTED BUT NOT SHOWN', etc.
   * @param {ExpressionNode} expression - What to observe
   * @param {string|null} target - Observer target (e.g., 'THE RECEIVER')
   */
  constructor(actionType, expression, target = null) {
    super('ObserverAction');
    this.actionType = actionType;
    this.expression = expression;
    this.target = target;
  }
}

// ============================================================================
// EXPRESSIONS
// ============================================================================

/**
 * Binary Expression - two operands and an operator
 */
export class BinaryExpressionNode extends ASTNode {
  /**
   * @param {string} operator - Spatial/gestural operator:
   *   'SCATTERED ACROSS', 'GATHERED INTO', 'PUT TOGETHER', 'REMOVED FROM',
   *   'TO BE DIMINISHED BY', 'PRESSED AGAINST', etc.
   * @param {ExpressionNode} left - Left operand
   * @param {ExpressionNode} right - Right operand
   */
  constructor(operator, left, right) {
    super('BinaryExpression');
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
}

/**
 * Unary Expression - single operand with operator
 */
export class UnaryExpressionNode extends ASTNode {
  /**
   * @param {string} operator - Unary operator: 'THE LACK OF', 'WHAT REMAINS AFTER', 'WITHOUT'
   * @param {ExpressionNode} operand - The operand
   */
  constructor(operator, operand) {
    super('UnaryExpression');
    this.operator = operator;
    this.operand = operand;
  }
}

/**
 * Identifier - variable reference
 */
export class IdentifierNode extends ASTNode {
  /**
   * @param {string} name - Variable name (without framing pipes)
   */
  constructor(name) {
    super('Identifier');
    this.name = name;
  }
}

/**
 * Literal - constant value
 */
export class LiteralNode extends ASTNode {
  /**
   * @param {*} value - The literal value
   * @param {string} literalType - Type: 'number', 'string', 'boolean', 'null'
   * @param {string|null} measurement - Measurement unit if applicable: 'INCHES', 'POUNDS', etc.
   */
  constructor(value, literalType, measurement = null) {
    super('Literal');
    this.value = value;
    this.literalType = literalType;
    this.measurement = measurement;
  }
}

/**
 * Array Literal
 */
export class ArrayLiteralNode extends ASTNode {
  /**
   * @param {Array<ExpressionNode>} elements - Array elements
   */
  constructor(elements) {
    super('ArrayLiteral');
    this.elements = elements;
  }
}

/**
 * Quantified Expression - expression with quantifier
 */
export class QuantifiedExpressionNode extends ASTNode {
  /**
   * @param {string} quantifier - Quantifier:
   *   'A', 'ENOUGH', 'NOT ENOUGH', 'TOO MUCH', 'A BIT OF',
   *   'A LITTLE BIT MORE', 'MORE OR LESS', 'GIVE OR TAKE',
   *   'SUFFICIENT', 'MANY', 'SOME'
   * @param {ExpressionNode} expression - The quantified expression
   */
  constructor(quantifier, expression) {
    super('QuantifiedExpression');
    this.quantifier = quantifier;
    this.expression = expression;
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Helper to create a literal node
 */
export function createLiteral(value, measurement = null) {
  let literalType;
  if (typeof value === 'number') {
    literalType = 'number';
  } else if (typeof value === 'string') {
    literalType = 'string';
  } else if (typeof value === 'boolean') {
    literalType = 'boolean';
  } else if (value === null) {
    literalType = 'null';
  } else {
    throw new Error(`Unknown literal type for value: ${value}`);
  }

  return new LiteralNode(value, literalType, measurement);
}

/**
 * Helper to create an identifier node
 */
export function createIdentifier(name) {
  return new IdentifierNode(name);
}

/**
 * Helper to create a binary expression
 */
export function createBinaryExpression(operator, left, right) {
  return new BinaryExpressionNode(operator, left, right);
}

// ============================================================================
// AST VISITOR BASE CLASS
// ============================================================================

/**
 * Base class for AST visitors
 * Subclass this to implement traversal logic
 */
export class ASTVisitor {
  visitProgram(node) {
    for (const possibility of node.possibilities) {
      this.visitPossibility(possibility);
    }
  }

  visitPossibility(node) {
    for (const statement of node.statements) {
      this.visitStatement(statement);
    }
    if (node.alternatives) {
      for (const alt of node.alternatives) {
        this.visitStatement(alt);
      }
    }
  }

  visitStatement(node) {
    this.visit(node.coreStatement);
  }

  visitAssignment(node) {
    this.visit(node.value);
  }

  visitRemoval(node) {
    // Leaf node, no children
  }

  visitConditional(node) {
    this.visit(node.condition);
    for (const stmt of node.thenStatements) {
      this.visitStatement(stmt);
    }
    for (const stmt of node.elseStatements) {
      this.visitStatement(stmt);
    }
  }

  visitLoop(node) {
    if (node.condition) this.visit(node.condition);
    if (node.count) this.visit(node.count);
    if (node.iterableExpr) this.visit(node.iterableExpr);
    for (const stmt of node.body) {
      this.visitStatement(stmt);
    }
  }

  visitFunctionDeclaration(node) {
    for (const stmt of node.body) {
      this.visitStatement(stmt);
    }
  }

  visitFunctionCall(node) {
    for (const arg of node.arguments) {
      this.visit(arg);
    }
  }

  visitReturn(node) {
    this.visit(node.value);
  }

  visitObserverAction(node) {
    this.visit(node.expression);
  }

  visitBinaryExpression(node) {
    this.visit(node.left);
    this.visit(node.right);
  }

  visitUnaryExpression(node) {
    this.visit(node.operand);
  }

  visitIdentifier(node) {
    // Leaf node, no children
  }

  visitLiteral(node) {
    // Leaf node, no children
  }

  visitArrayLiteral(node) {
    for (const elem of node.elements) {
      this.visit(elem);
    }
  }

  visitQuantifiedExpression(node) {
    this.visit(node.expression);
  }

  visit(node) {
    if (!node) return;

    const methodName = `visit${node.type}`;
    if (this[methodName]) {
      this[methodName](node);
    } else {
      throw new Error(`No visitor method for node type: ${node.type}`);
    }
  }
}
